# 生成树
- [并查集](#并查集)
- 最小生成树
    - [kruskal]()

## 并查集
通俗地讲,就是一种把点集合化的方式.
```c++
int far[maxn];      //储存他是哪个集合的

//返回x节点的源节点
int find(int x)
{
    if(far[x] == x)
        return x;
    return find(far[x]);
}

//将两个节点化为一个集合
void unionn(int x,int y)
{
    far[find(y)] = find(x);
}
```

## Kruskal
最小生成树的一种算法，适合于稀疏图。
具体流程就是：
1. 先将每一条边的权重按照从小到大排序，重复执行以下步骤
2. 选取最短的边，检查是否构成环路，没有的话，然后将这个边加入选中集合
3. 如果边的数量达到了n-1，退出循环

看模板
```c++
sort(edge,edge+n,cmp);
for(int i = 0;i<n;++i)
{
    if(k+1 == m-1)          //如果边的数量=点的数量-1
        break;
    if(find(edge[i].from) != find(edge[i].to))  //判断是否构成环路
    {
        unionn(edge[i].from, edge[i].to);
        total+=edge[i].dis;
        k++;
    }
}
```