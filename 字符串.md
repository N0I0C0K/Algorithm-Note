# 字符串
和字符串相关

## 字符串
术语|概念
----|---
子串|$S[i:j]$，依次取$S[i], S[i+1].... S[j]$
子序列|从S中任取诺干元素，但不更改其相对位置
后缀|$S[i:end]$，指的是从第i个一直取到最后一个所构成的子串
真后缀|不包括$S$本身的后缀
前缀|$S[0:i]$的子串
真前缀|不包括它本身的前缀
字典序|以第i个关键字作为比较，空字符小于任何字符，所以$a<aa$
回文串|正着读倒着读都一样的字符串

## 字符串匹配（朴素算法）
也可以称作暴力法
考虑一个字符串$abcabcabc$, 和匹配的字符串$ab$, 我们只需要挨个判断是否相等就行了
```python
def match(s:str, t:str):
    n = len(s)
    m = len(t)
    ans = []
    for i in range(0, n - m + 1):
        for j in range(0, m):
            if s[i + j] != t[j]:
                break
        if j == m:
            ans.append(i)
    return ans
```

## KMP算法


## 字符串哈希
一定记住：**两个元素若全等，其哈希值必定也相等；但哈希值相等，两个元素未必全等**
或者说进制哈希,可以拿十进制来类比
- 一般的公式为:
$hash[i] = hash[i-1]*base+s[i]$
其中$hash[i]$表示字符串前$i$个字符的哈希值
- 所以我们可以推算出长度为$x$的字串的哈希值为:
$h = hash[i]-hash[i-x]*base^x$
感觉是不是有前缀和那味了

**注意事项：**
1. 一般来讲base一般选择$131$或者$13331$,可以使冲突最小。
2. 我们把hash储存在`unsigned long long`,让他自然溢出。

**模板**
```c++
using ull = unsigned long long;
ull hash[maxn];
ull base = 131;
ull p[maxn];    //预处理进制，理解为：base^x
void initHash(char *s)
{
    p[0] = 1;
    hash[0] = 0;    //前0个字符的hash为0
    int n = strlen(s);
    for(int i = 1;i <= n;++i)
    {
        p[i] = p[i-1]*base;
        hash[i] = hash[i-1]*base+(ull)s[i];
    }
}

ull get(int l, int r)
{
    return hash[r]-hash[l-1]*p[r-l+1];
}
```
**练习:**
https://www.luogu.com.cn/problem/P3370

### 二维字符串哈希
上面说的都是一维字符串哈希，下面说的是二维字符串哈希。
~~待补充~~